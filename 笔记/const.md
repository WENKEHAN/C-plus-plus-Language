## 1.const限定符

它的值不能够被改变

CONST一旦创建后就必须初始化

万能引用--都可以引用

### 如何在一个文件中定义const的时候同时在其它文件中使用它

不论在声明还是在定义的时候添加上extern关键字

```C++
//在file.cpp文件中定义了一个常量，该常量可以被其它文件所访问
extern const int bufsize=fcn();
//file.h头文件
extern const int bufzie;//与上面的是同一个
```

### const的引用

对常量的引用不能够修改它所绑定的对象

```C++
const int ci=1024;
const int &ri=ci;//正确，引用及其对应的对象都是常量
r1=42;//错误，ri是对常量的引用，不能够修改它所绑定的对象
int &r2=ci;//错误，r2是一个非常量
```

### 初始化和对const的引用

​	引用对象一致的例外情况：
​	1·初始化时允许任意表达式作为其初始值，只要改表达式的结果可以转换成引用的类型即可
​	2·允许一个常量，引用绑定非常量的对象

```C++
int i=42;
const int &r1=i;//允许常量绑定一个非常量的对象
const int &r2=42;//正确
const int &r3=r2*2;//正确允许表达式
int &r4=r1*2;//错误不允许一个变量引用一个常量
```

## 2·引用

### 引用的特点

1. 不能够定义空引用-必须初始化 --没有空引用
2. 没有引用的引用

### 左值引用和右值引用的区别

1. 左值---可以取地址的变量

2. 右值--无法取它的地址

3. 引用字面常量可以使用右值引用

   ```C++
   int &&a=10;
   ```

## 3·指针和引用的区别

#### 指针

1. 空指针
2. 野指针
3. 失效指针

### 从语法规则上讲

1. 指针变量存储某个对象的的地址，引用是实例的别名
2. 程序为指针变量分配存储区域；而不为引用分配内存区域
3. 解引用时-指针使用要在前加"*"；引用可以直接使用
4. 指针变量的的值可以发生改变，存储不同实例的地址；引用在定义时就需要初始化，之后无法改变（不能是其他实例 的引用）
5. 指针变量的值可以为空（NULL，nullptr）;没有空引用
6. 指针变量作为形参的时候需要判断其合法性（判空NULL）；引用不需要
7. 对指针变量使用"sizeof"的到的是指针变量的大小；对引用变量使用"sizeof"的到的是变量的大小
8. 理论上指针的级数没有限制；引用之只有一级 ，不存在引用的引用，可以有指针的指针
9. ++ 引用与++指针操作不一样
   1. 对指针进行++ 操作，会使得变量指向下一个对象的地址，而不是改变其所指的内容
   2. 对引用的操作直接反应到所引用的实体
10. ***不可以对函数中的局部比变量或对象以引用或指针方式返回***
    1. ***如果返回的是指针时，要成为全局变量才可以--标识符的实体不受函数的影响***


### 从汇编层面来看

​	引用也是指针，不过是const修饰的常性指针

​	**汇编层面做的改变**

<a href="https://imgtu.com/i/OlegyD"><img src="https://s1.ax1x.com/2022/05/07/OlegyD.md.png" alt="OlegyD.png" border="0" /></a>

### 什么时候使用引用，什么时候使用传值

**内置数据类型用传值**

​	一次访问

**自定义数据类型用引用**

两次访问

结构体用引用-因为只传地址

##  4·基地内联函数inline-提高调用速度

3 4行的代码就会启动inline，如果函数过长就会调用-是否调用在于函数是否短小（除了递归）

1. 调用速度快
2. 时间换空间-省去调用时间
3. 声明和定义不要分离

##  5·缺省参数

1. 函数的实参个数可以与形参不相同
2. 缺省参数指定在定义函数为形参指定缺省值
3. 缺省值并不一定是常量表达式，也可以式任意表达式或者通过函数调用给出
4. 多文件结构中-函数声明中给默认值
5. 不能用一个函数的默认值作为另一个参数的默认值
6. 函数声明时--形参名可以省掉

```C++
void fun(int a,int b,int c=0,int d=0)
    //只允许从左往右进行缺省，不能够跨过或者从左到右
fun(1,2);//实参可以给2个
fun(1,2,3,4);//可以全部给
fun(1,2,,4);//中间不能够空
```

## 6·函数重载--根据形参类型的不同作为重载的依据

如果面试官不继续深入：也可以根据值的型别

1. 链接的过程中产生关联

   

## 7·lvalue、rvalue、xvalue(左值、右值、将亡值)

<a href="https://imgtu.com/i/O3rXfs"><img src="https://s1.ax1x.com/2022/05/08/O3rXfs.md.png" alt="O3rXfs.png" border="0" /></a>



auto 为什么可以推出  

名字粉碎：

因为在编译的过程中，函数返回值已经作为--函数在底层重命名的一部分，所以可以推导出来

<a href="https://imgtu.com/i/O3ybGj"><img src="https://s1.ax1x.com/2022/05/08/O3ybGj.md.png" alt="O3ybGj.png" border="0" /></a>



## 8·模板函数

<a href="https://imgtu.com/i/O3WXQJ"><img src="https://s1.ax1x.com/2022/05/08/O3WXQJ.md.png" alt="O3WXQJ.png" border="0" /></a>



### 为什么不是替换

类型是重命名规则

<a href="https://imgtu.com/i/O34rZR"><img src="https://s1.ax1x.com/2022/05/08/O34rZR.md.png" alt="O34rZR.png" border="0" /></a>















